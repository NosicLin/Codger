<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>识别算法</TITLE>
<META NAME="description" CONTENT="识别算法">
<META NAME="keywords" CONTENT="index">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="index.css">

<LINK REL="next" HREF="node18.html">
<LINK REL="previous" HREF="node16.html">
<LINK REL="up" HREF="node14.html">
<LINK REL="next" HREF="node18.html">
</HEAD>

<BODY >

<DIV CLASS="navigation"><!--Navigation Panel-->
<A NAME="tex2html303"
  HREF="node18.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="/usr/share/latex2html/icons/next.png"></A> 
<A NAME="tex2html301"
  HREF="node14.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="/usr/share/latex2html/icons/up.png"></A> 
<A NAME="tex2html295"
  HREF="node16.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="/usr/share/latex2html/icons/prev.png"></A>   
<BR>
<B> Next:</B> <A NAME="tex2html304"
  HREF="node18.html">状态机的合并</A>
<B> Up:</B> <A NAME="tex2html302"
  HREF="node14.html">词法识别算法</A>
<B> Previous:</B> <A NAME="tex2html296"
  HREF="node16.html">状态的结构</A>
<BR>
<BR></DIV>
<!--End of Navigation Panel-->

<H2><A NAME="SECTION00033000000000000000">
识别算法</A>
</H2>
Codger的词法识别算法是基于有限状态机，在词法识别模块保存了一个完整的，能识别到codger语言中所有单词的有限状态机。当解析器解析codger源程序时,采用最大识别的方法，下面为识别一个单词大概步骤：

<OL>
<LI>置当前状态置为有限状态机的开始状态
</LI>
<LI>从输入字符流中读出一个字符
</LI>
<LI>根据当前状态与输入字符确定下一个状态,并置当前状态为下一状态
</LI>
<LI>处理当前状态，当前状态的类型有三种情况：普通状态，终态，错误状态
 
<OL>
<LI>普通状态：跳转的步聚2
</LI>
<LI>终态：则记录下该状态与输入字符流的位置。并且跳转到步聚2
</LI>
<LI>错误状态：查看以前是否到达过终态,如果是则选择最近一次到达的终态，把多识别的字符返回给输入字符流,返回该单词的类型。如果没有到达过终态，则表明源程序中存在词法错误，返回出错信息。
 
</LI>
</OL>
</LI>
</OL>
用代码来描述为：<PRE>
GetToken(f)                    
    cur_state=begin_state      #设置当前状态为开始状态
    finally_state=Nil          #以及初始化程序数据
    file_pos=Nil
    while true 
        c=f.getchar()                 #从文件读出一个字符
        cur_state=cur_state.next(c)   #获取下一状态
        if cur_state==err         
            if finally_state!= Nil    #以前到达过终态
                f.set_read_pos(file_pos)  
                return finally_state.token  
            else                      #以前没有到达过终态
                return  ERR_TOKEN  
            end
        elif cur_state.finally        #如果为终态
            finally_state=cur_state   #保存该状态
            file_pos=f.get_read_pos   #保存文件的读位置
        end
    end
end
</PRE><BLOCKQUOTE>

<DIV ALIGN="CENTER">
代码4.3.1

</DIV>
其中State.next的代码如下:

</BLOCKQUOTE><PRE>
State.next(c)
    input_type=State.input_map[c]    #获取输入类型
    return State.targets[input_type] #找到后继状态并返回
end
</PRE>

<P>
涉及到识别到错误状态时，读位置的回退操作，回退的平均位移为2，所以代码4.3.1的时间算杂度与基本上与源文件的字符长度成正比。

<P>
<BR><HR>
<ADDRESS>
NosicLin
2012-06-03
</ADDRESS>
</BODY>
</HTML>
