<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>词法识别算法</TITLE>
<META NAME="description" CONTENT="词法识别算法">
<META NAME="keywords" CONTENT="index">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="index.css">

<LINK REL="next" HREF="node4.html">
<LINK REL="previous" HREF="node2.html">
<LINK REL="up" HREF="index.html">
<LINK REL="next" HREF="node4.html">
</HEAD>

<BODY >

<DIV CLASS="navigation"><!--Navigation Panel-->
<A NAME="tex2html167"
  HREF="node4.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html165"
  HREF="index.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html159"
  HREF="node2.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A>   
<BR>
<B> Next:</B> <A NAME="tex2html168"
  HREF="node4.html">数据类型</A>
<B> Up:</B> <A NAME="tex2html166"
  HREF="index.html">index</A>
<B> Previous:</B> <A NAME="tex2html160"
  HREF="node2.html">词法</A>
<BR>
<BR></DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL CLASS="ChildLinks">
<LI><A NAME="tex2html169"
  HREF="node3.html#SECTION00031000000000000000">状态链简介</A>
<LI><A NAME="tex2html170"
  HREF="node3.html#SECTION00032000000000000000">状态的结构</A>
<LI><A NAME="tex2html171"
  HREF="node3.html#SECTION00033000000000000000">识别算法</A>
<LI><A NAME="tex2html172"
  HREF="node3.html#SECTION00034000000000000000">状态机的合并</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION00030000000000000000">
词法识别算法</A>
</H1>
在前面一部分给出了在codger中所有的单词,以及描述单词结构的bnf文法，这些文法都是正则文法。正则文法与有限状态机具有等价性，它们之间可以相互转换<A NAME="tex2html2"
  HREF="footnode.html#foot100"><SUP><SPAN CLASS="arabic">1</SPAN></SUP></A>。而词法识别算法通常是通过构造有限状态机的方法来识别源程序中的不同类型的单词，状态机可以使用类似于lex的词法分析软件自动生成，这种方法处理起来简单，只需要遵守词法分析软件的使用规则即可，或者程序员可以通过手工来构造状态机。手工构造相比词法分析软件相比优点在于:

<OL>
<LI>词法分析软件有固定处理框架，不能随意改变，限定了程序的灵活性。手工构造则没有这种限制。
</LI>
<LI>词法分析软件根据一定算法生成有限状态机，其中有许多重复的或者是多余的状态都可以被优化掉。
</LI>
</OL>
但手工构造如果处理不好，可能会随着正则语言规模的增大，复杂度也跟着增加，最终可以超出人脑可能处理的限度。下面介绍一种在codger词法分析模块中使用的一种算法-状态链。

<H2><A NAME="SECTION00031000000000000000">
状态链简介</A>
</H2>
在codger解析器的早期版本中，采用状态矩阵<A NAME="tex2html3"
  HREF="footnode.html#foot104"><SUP><SPAN CLASS="arabic">2</SPAN></SUP></A>的方法来识别源程序中的单词。但由于状态矩阵算法会随着正则文法规模的增大，复杂度也跟着增加，每次当需要变更每个单词的结构时，都需要更改一大堆数据，使解析器的维护的扩展都变得非常困难，而且极容易出错。最后不得不放弃状态矩阵，而寻找新的方法。

<P>
状态链识别法是在codger解析器开发过程中总结出的一种非常实用和高效的算法，之所以命名为状态链，因为状态链算法处理的最多的是状态与状态之间的链接。状态链算法优点再于：

<OL>
<LI>随着正则文法规模的变大，其复杂度一般情况下不会增加。
</LI>
<LI>状态链是一种分治算法，它先通过为每一个不同类型的单词构造子状态机，然后再通过合并算法把子状态机合并在一起，合并时，不需要更改子状态机中的数据和状态，只需增加新的状态链接到子状态机中已有的状态。
</LI>
<LI>状态机中的每个状态只需要处理它所接受输入事件类型，以及在该输入事件类型下的后继状态，而不用去了解状态机的整体结构。当状态机的结构发生变化时，很多状态都可以直接得到重用，使解析器的维护和扩展变得非常容易。
</LI>
</OL>
<H2><A NAME="SECTION00032000000000000000">
状态的结构</A>
</H2>
状态链算法中，许多的状态链接在一起构成一个有限状态机，在每个状态中都会保存与该状态相关的基本信息，这些信息有：

<OL>
<LI>状态是否为终态，如果是终态，同时也会保存该状态所属单词的类型，单词类型用于后面的语法分析。
</LI>
<LI>字符映射数组：字符射数组长度为256，codger源程序是由字符序列组成，每当解析器从源程序中读出一个字符时，该字符的值的范围为：0到255，然后从字符映射数组获得输入事件类型。
</LI>
<LI>状态能接受的输入事件类型，以及在该输入类型下所转换到的后继状态。
</LI>
</OL>
用程序来描述为(attr表示属性定义)：<PRE>
class State
    attr finally        #是否为终态
    attr token          #单词的类型
    attr input_map[256] #字符映射数组
    attr targets[]      #后继状态
end
</PRE>
例如：假设状态a为不为终态，在字符`0'到`9'下转移到状态b，在`a'到`f'下转移到状态c，在其它状态下，转换到错误状态。为状态a构造状态数据为：<PRE>
State a
    finally=false
    token="unkown"
    input_map=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
               1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0
               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
               0,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0
               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                       .........
               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    targets=[err,b,c]
end
</PRE>

<P>
其中在input_map中的省略号为112个0，状态a总共能接受三种输入事件类型，由于数组脚标从零开始，所以三种输入事件类型分别称为输入事件0，输入事件1，输入事件2

<OL>
<LI>输人字符`0'到`9'会被映射为第1种输入事件类型，状态a在该输入类型下会转移到后继状态b，状态b保存在targets中的脚标为1的位置
</LI>
<LI>输入字符`a'到`f'会被映射为第2种输入事件类型，状态a在该输入类型下会转移到后继状态c，状态c保存在targets中的脚标为2的位置
</LI>
<LI>除`0'到`9'和`a'到`f'以外的所有字符会被映射到第0种输入事件类型，状态a在该输类型下会转移到后断状态err，状态err保存在targets中的脚标为0的位置。状态err是一个内置状态，用于表示源程于中单词存在错误。
</LI>
</OL>

<P>
input_map是一个256位的数组，数组元素类型为unsigned char， unsigned char占用一个字节，即一个input_map需要256字节。但并不是每个状态都需要独自拥有一个字符映射数组。在很多情况下，许多状态的输入事件类型相似，或者是完全相同，它们可以建立一个公有的字符映射数组，用于共享，以提高内存的利用率。例如状态a在符号`c'到`z'转换到状态c，状态b在字符`a'到`f'能转换到状态c，虽然状态a与状态b能接受的输入事件类型不同，但是可能通过合并状态a与状态b输入事件，让它们共享一个字符映射数组。合并方法为：提取出字符`c'到z'与字符`a'到`f'两个序列范围的交集部分为：字符`c'到`f'，即现在的有四种输入类型
<BLOCKQUOTE>
1) 类型0, 字符`a'到`b' 
<BR>
2) 类型1, 字符`c'到`f' 
<BR>
3) 类型2, 字符`g'到`z' 
<BR>
4) 类型3, 除前面字符以外的所有字符。 

</BLOCKQUOTE>
以前状态a是在字符`c'到`z'转换到状态c，现在改为在字符`a'到`b'与字符`c' 到 `f'的情况下转换到c；以前状态b是在字符`c'到`z'转换到状态c，现在改为在字符`c'到`f'与字符`g'到`z'的情况下转移到状态c。在合并字符映射数组后，a的后继状态数组改为[c,c,err,err]，b的后继状态数组为[err,c,c,err]。

<P>
Codger解析器的词法识别模块大约有90多个状态和10字符映射组成，基本上每种单词类型的所有状态共享一个状态映射数组。词法识别模块所占用的内存大约在4k左右。

<H2><A NAME="SECTION00033000000000000000">
识别算法</A>
</H2>
Codger的词法识别算法是基于有限状态机，在词法识别模块保存了一个完整的，能识别到codger语言中所有单词的有限状态机。当解析器解析codger源程序时,采用最大识别的方法，下面为识别一个单词大概步骤：

<OL>
<LI>置当前状态置为有限状态机的开始状态
</LI>
<LI>从输入字符流中读出一个字符
</LI>
<LI>根据当前状态与输入字符确定下一个状态,并置当前状态为下一状态
</LI>
<LI>处理当前状态，当前状态的类型有三种情况：普通状态，终态，错误状态
 
<OL>
<LI>普通状态：跳转的步聚2
</LI>
<LI>终态：则记录下该状态与输入字符流的位置。并且跳转到步聚2
</LI>
<LI>错误状态：查看以前是否到达过终态,如果是则选择最近一次到达的终态，把多识别的字符返回给输入字符流,返回该单词的类型。如果没有到达过终态，则表明源程序中存在词法错误，返回出错信息。
 
</LI>
</OL>
</LI>
</OL>
用代码来描述为：<PRE>
GetToken(f)                    
    cur_state=begin_state      #设置当前状态为开始状态
    finally_state=Nil          #以及初始化程序数据
    file_pos=Nil
    while true 
        c=f.getchar()                 #从文件读出一个字符
        cur_state=cur_state.next(c)   #获取下一状态
        if cur_state==err         
            if finally_state!= Nil    #以前到达过终态
                f.set_read_pos(file_pos)  
                return finally_state.token  
            else                      #以前没有到达过终态
                return  ERR_TOKEN  
            end
        elif cur_state.finally        #如果为终态
            finally_state=cur_state   #保存该状态
            file_pos=f.get_read_pos   #保存文件的读位置
        end
    end
end
</PRE><BLOCKQUOTE>

<DIV ALIGN="CENTER">
代码4.3.1

</DIV>
其中State.next的代码如下:

</BLOCKQUOTE><PRE>
State.next(c)
    input_type=State.input_map[c]    #获取输入类型
    return State.targets[input_type] #找到后继状态并返回
end
</PRE>

<P>
涉及到识别到错误状态时，读位置的回退操作，回退的平均位移为2，所以代码4.3.1的时间算杂度与基本上与源文件的字符长度成正比。

<P>

<H2><A NAME="SECTION00034000000000000000">
状态机的合并</A>
</H2>
在前面介绍过，状态链算法是一种分治的算法，其主要思想为先为每个不同类型的单词构造子状态机，然后通过合并算法把子状态机合并成为一个大的综合性的状态机。假设现在有两个状态机:
<BLOCKQUOTE>
1) 状态机A用于识别正则式[0-7]+abf所表示的语言，如图<A HREF="#fig:state_a"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>
<BR>
2) 状态机B用于识别正则式[4-9]+acd所表示的语言，如图<A HREF="#fig:state_b"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>

</BLOCKQUOTE>

<DIV ALIGN="CENTER"><A NAME="fig:state_a"></A><A NAME="144"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure:</STRONG>
状态机A</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">

</DIV> <IMG
  WIDTH="363" HEIGHT="336" ALIGN="BOTTOM" BORDER="0"
 SRC="./s_a.png"
 ALT="Image s_a"></TD></TR>
</TABLE>
</DIV>

为了减少字符映射数组的使用，让状态机A的所有状态共享一个状态映射数组，这样一来，对于每个状态来说就有5种输入类型，同样也就有5个后继状态：
<BLOCKQUOTE>
1) 数字0到7，命名为 D0_7  
<BR>
2) 字符a，命名为 S_a  
<BR>
3) 字符b，命名为 S_b 
<BR>
4) 字符f，命名为 S_f 
<BR>
5) 除以上字符以外的所有字符，命名为 Other

</BLOCKQUOTE>
例如状态机A中的状态A1的后继状态为：[A1,A2,err,err,err] 

<P>
同样对状态机B中的所有状态也让它们共享一个状态映射数组，则对于每个状态来说，输入类型有5种，5个后继状态：
<BLOCKQUOTE>
1) 数字4到9，命名为 D4_9 
<BR>
2) 字符a，命名为 S_a 
<BR>
3) 字符c，命名为 S_c 
<BR>
4) 字符d, 命名为 S_d 
<BR>
5) 除以上字符以外的所有字符，命名为 Other

</BLOCKQUOTE>

<DIV ALIGN="CENTER"><A NAME="fig:state_b"></A><A NAME="153"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure:</STRONG>
状态机B</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">

</DIV> <IMG
  WIDTH="287" HEIGHT="320" ALIGN="BOTTOM" BORDER="0"
 SRC="./s_b.png"
 ALT="Image s_b"></TD></TR>
</TABLE>
</DIV>

合并过程如下：
<DL>
<DT><STRONG>第一步:</STRONG></DT>
<DD>合并状态机A与状态B的输入类型，找出相交输入类型，提取出它们的公有子集，输入类型合并的有9种：
<BLOCKQUOTE>
1) 数字0到3, 命名为 D0_3 
<BR>
2) 数字4到7, 命名为 D4_7 
<BR>
3) 数字8到9, 命名为 D8_9 
<BR>
4) 字符a,  命名为 S_a 
<BR>
5) 字符b,  命名为 S_b 
<BR>
6) 字符c,  命名为 S_c 
<BR>
7) 字符d,  命名为 S_d 
<BR>
8) 字符f,  命名为 S_f 
<BR>
9) 除以上字符以外的所有字符, 命名为 Other

</BLOCKQUOTE>
其中状态机A中的输入类型D0_7被分解成为了输入类型D0_3和D4_7；状态机中的输入类型D4_9被分解成了输入类型D4_7和D8_9
</DD>
<DT><STRONG>第二步:</STRONG></DT>
<DD>状态机A的开始状态为Abegin，状态机B的开始状态为Bbegin，创建一个状态复合状态 {Abeign ,Bbegin}, 把该复合状态命名为Cbegin，并且标记Cbegin。其中复合状态的定义为：复合状态中的任意一个状态能在某种输入类型下发生状态转移，该复合状态也能在该输入类型下发生状态转移，并且后继状态相同。
</DD>
<DT><STRONG>第三步:</STRONG></DT>
<DD>找出一个被标记的复合状态，现在只有Cbeign被标记，所以取出 Cbegin，然后取消标记 Cbeign，并确定Cbegin的后继状态，Cbeign 为 {Abegin ,Bbegin} 的复合状态：
<BR>因为：<PRE>
f(Abegin,D0_7)-&gt;A1
f(Bbegin,D4_9)-&gt;B1
</PRE>
推出：<PRE>
f(Cbegin,D0_3)-&gt;A1
f(Cbegin,D4_7)-&gt;{A1,B1}
f(Cbegin,D8_9)-&gt;B1
</PRE>
CBegin的转换情况如下表<A NAME="tex2html6"
  HREF="footnode.html#foot167"><SUP><SPAN CLASS="arabic">3</SPAN></SUP></A>:

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER">状态输入</TD>
<TD ALIGN="CENTER">D0_3</TD>
<TD ALIGN="CENTER">D4_7</TD>
<TD ALIGN="CENTER">D8_9</TD>
<TD ALIGN="CENTER">S_a</TD>
<TD ALIGN="CENTER">S_b</TD>
<TD ALIGN="CENTER">S_c</TD>
<TD ALIGN="CENTER">S_d</TD>
<TD ALIGN="CENTER">S_f</TD>
<TD ALIGN="CENTER">Other</TD>
</TR>
<TR><TD ALIGN="CENTER">CBegin</TD>
<TD ALIGN="CENTER">A1</TD>
<TD ALIGN="CENTER">A1,B1</TD>
<TD ALIGN="CENTER">B1</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
</TR>
</TABLE>

<P>
在确定后继状态，需要处理的其中的复合状态，Cbeign在输入事件D4_7下转移到复合状{A1,B1}，该复合状态以前并没出现过，创建复合状态{A1,B1}，把该状态命名为C1,标记C1。
</DD>
<DT><STRONG>第四步:</STRONG></DT>
<DD>检测现在是否存在被标记的复合状态，如果存在，跳转到第三步。如果没有，则状态机的合并完成。现在状态C1被标记，将其取出，取消标记C1，C1 为 {A1,B1} 的复合状态:
<BR>因为：<PRE>
f(A1,D0_7)-&gt;A1
f(A1,S_a)-&gt;A2
f(B1,D4_9)-&gt;B1
f(B1,S_a)-&gt;B2
</PRE>
推出：<PRE>
f(C1,D0_3)-&gt;A1
f(C1,D4_7)-&gt;{A1,B1}
f(C1,D8_9)-&gt;B1
f(C1,S_a)-&gt;{A2,B2}
</PRE>

<P>
C1的状态转移如下表:

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER">状态输入</TD>
<TD ALIGN="CENTER">D0_3</TD>
<TD ALIGN="CENTER">D4_7</TD>
<TD ALIGN="CENTER">D8_9</TD>
<TD ALIGN="CENTER">S_a</TD>
<TD ALIGN="CENTER">S_b</TD>
<TD ALIGN="CENTER">S_c</TD>
<TD ALIGN="CENTER">S_d</TD>
<TD ALIGN="CENTER">S_f</TD>
<TD ALIGN="CENTER">Other</TD>
</TR>
<TR><TD ALIGN="CENTER">C1</TD>
<TD ALIGN="CENTER">A1</TD>
<TD ALIGN="CENTER">A1,B1</TD>
<TD ALIGN="CENTER">B1</TD>
<TD ALIGN="CENTER">A2,B2</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
</TR>
</TABLE>

<P>
C1的后继中状态中有两个复合状态，其中复合状态{A1,B1}在以前已经被创建过，所以不对其进行处理。复合状态{A2,B2}以前没有出现过，则创建它，并且标记，把它命名为C2。

<P>
现在还存在标记的复合状态C2，所以继续按照每二步的方法来处理，取出C2，取消标记，C2为 {A2, B2} 的复合状态: 
<BR>因为：<PRE>
f(A2,S_b)=A3
f(B2,S_c)=B3
</PRE>
推出:<PRE>
f(C2,S_b)=A3
f(C2,S_c)=B3
</PRE>

<P>
C2的状态转移如下表：

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER">状态输入</TD>
<TD ALIGN="CENTER">D0_3</TD>
<TD ALIGN="CENTER">D4_7</TD>
<TD ALIGN="CENTER">D8_9</TD>
<TD ALIGN="CENTER">S_a</TD>
<TD ALIGN="CENTER">S_b</TD>
<TD ALIGN="CENTER">S_c</TD>
<TD ALIGN="CENTER">S_d</TD>
<TD ALIGN="CENTER">S_f</TD>
<TD ALIGN="CENTER">Other</TD>
</TR>
<TR><TD ALIGN="CENTER">C2</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">A3</TD>
<TD ALIGN="CENTER">B3</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
</TR>
</TABLE>
</DD>
</DL>

<P>
现在以经没有被标记过的状态，表示状态机的整个合并过程完成，合并后创建了3个新状态：CBegin, C1, C2。每个状态接受的输入类型有9个，但可以对其进行优化，因为三个状态在输入类型 S_d, S_f ,Other 下都转移到err，可以把它们合并到输入类型Other中，即最终的输入类型7个：
<BLOCKQUOTE>
1) 数字0到3, 命名为 D0_3 
<BR>
2) 数字4到7, 命名为 D4_7 
<BR>
3) 数字8到9, 命名为 D8_9 
<BR>
4) 字符a,  命名为 S_a 
<BR>
5) 字符b,  命名为 S_b 
<BR>
6) 字符c,  命名为 S_c 
<BR>
7) 除以上字符以外的所有字符, 命名为 Other

</BLOCKQUOTE>
合并后的状态图为：图<A HREF="#fig:state_c"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>, 每个状态后继状态如下：
<BLOCKQUOTE>
1) CBegin后继状态为：[A1,C1,B1,err,err,err,err]  
<BR>
2) C1后继状态为：[A1,C1,B1,C2,err,err,err] 
<BR>
3) C2后继状态为:[err,err,err,err,A3,B3,err] 

</BLOCKQUOTE>

<DIV ALIGN="CENTER"><A NAME="fig:state_c"></A><A NAME="201"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure:</STRONG>
状态机A与状态机B后并后</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">

</DIV><IMG
  WIDTH="313" HEIGHT="551" ALIGN="BOTTOM" BORDER="0"
 SRC="IGimg1.png"
 ALT="Image s_c"></TD></TR>
</TABLE>
</DIV>

状态机A与状态B的合并过程中，并不会改变状态A与状态机B的任何一个状态的信息，合并后创建了3个的新状态。新状态通过后继状态链接到子状态机A与子状态机B中的状态。把识别算法中的开始状态改为Cbegin，就可以对正则式[0-7]+abf和[4-9]+acd表示的语言进行识别。因为子状态的数据没有被改变，当只需要识别正则式[0-7]+abf所表示的语言时，同样也只需要把识别算法中的开始状态改变Abegin即可，这种特性使模块的调试变得很简单，可以先测试子状态机A和子状态机B是否正确，然后再测试合并后的状态机是否正确。

<P>
在Codger词法中有9个不同类型的单词，关键字的识别是通用先识别出标识符，然后再判断标识符是否属于关键字。子状态机有8个，识别每种单词类型子状态机的开始符号所接受的输入事件类型之间的交集很少，例如：注释以#号开头，整数和以数字开头，浮点数以数字和点号开头，字符串以双引号开头，标识符以字母开头，在合并的时，涉及到的复合状态很少，最复杂的合并属于浮点数与整数的合并，但合并后也只创建了4个新的状态。

<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A NAME="tex2html167"
  HREF="node4.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html165"
  HREF="index.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html159"
  HREF="node2.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A>   
<BR>
<B> Next:</B> <A NAME="tex2html168"
  HREF="node4.html">数据类型</A>
<B> Up:</B> <A NAME="tex2html166"
  HREF="index.html">index</A>
<B> Previous:</B> <A NAME="tex2html160"
  HREF="node2.html">词法</A></DIV>
<!--End of Navigation Panel-->
<ADDRESS>
NosicLin
2012-06-03
</ADDRESS>
</BODY>
</HTML>
