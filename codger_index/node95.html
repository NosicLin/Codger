<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>页分配算法</TITLE>
<META NAME="description" CONTENT="页分配算法">
<META NAME="keywords" CONTENT="index">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="index.css">

<LINK REL="next" HREF="node96.html">
<LINK REL="previous" HREF="node94.html">
<LINK REL="up" HREF="node93.html">
<LINK REL="next" HREF="node96.html">
</HEAD>

<BODY >

<DIV CLASS="navigation"><!--Navigation Panel-->
<A NAME="tex2html1151"
  HREF="node96.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="/usr/share/latex2html/icons/next.png"></A> 
<A NAME="tex2html1149"
  HREF="node93.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="/usr/share/latex2html/icons/up.png"></A> 
<A NAME="tex2html1143"
  HREF="node94.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="/usr/share/latex2html/icons/prev.png"></A>   
<BR>
<B> Next:</B> <A NAME="tex2html1152"
  HREF="node96.html">内存分配算法</A>
<B> Up:</B> <A NAME="tex2html1150"
  HREF="node93.html">内存管理</A>
<B> Previous:</B> <A NAME="tex2html1144"
  HREF="node94.html">内存管理模块的组成</A>
<BR>
<BR></DIV>
<!--End of Navigation Panel-->

<H2><A NAME="SECTION00092000000000000000">
页分配算法</A>
</H2>
页是整个内存管理模块的核心，QuickMem模块基于页实现快速内存分配，Gc模块中的堆也是基于页实现的。MemBase模块中实现的页分配接口，以供level2使用。它的实现方法为每次利用c库的malloc函数每配一大块内存，这一大块内存被称作为域(Area）。在Codger中域的大小为1M，从域的起始地起开始，找到第一个页对齐的起地址，从该地址开始，以页大小为基础分配内存，直到最后的内存小于页的大小。Area最前面和最尾部的一小段内存都无法使用。

<P>
MemBase模块中，用AreaHeader来表示每一个Area，如果Area中的所有页都被会配完，则Area会被放到full_list中。如果Area有页可以分配，则它会被放到free_list中， cur_area 表示用于当前分配页的Area。 
<BR>
MemBase的PageAlloc算法为：<PRE>
MemBase.AllocPage()
    if cur_area==Nil
        if free_list.not_empty()      #如果free_list 不分空
             cur_area=free_list.take_front() #取出free_list中第一个Area
        else
             cur_area=AllocNewArea()  #分配一个新的Area
        end
     end 
     page=cur_area.alloc()       #从当前area中分出一页
     if cur_area.full()          #如果area没有空闲页，则放到full_list中
        full_list.add(cur_area)
        cur_area=Nil
     end
     return page
end
</PRE>
MemBase的PageFree算法：<PRE>
MemBase.FreePage(page)
    area = FindPageArea(page)    #找到page所在的area
    if area.full()       #如果area以前没有空闲页，则它在full_list中
       full_list.del(area)     #现在一页被释放后，从full_list中删除
       free_list.add_front(are)  #放入到free_list中
    end
    area.FreePage(page)          #把页page还给area
    if area.alloced_page_nu==0   #如果area的全部页都被归还
       if area!=cur_area        
           free_list.del(area)   #则把内存还给操作系统
           FreeArea(area)
       end
    end
end
</PRE>
其中FindPageArea首先判断page是否在cur_area中，判断方法是通过page的地起是否在area的地起范围内，然后再遍历free_list中的每一个area，最后是full_list。

<P>
AreaHeader用来管理一个Area中的所有数据，包括Area中的空闲页，总共可分配的页的数量，已分配页的数量等，它的结构如下：<PRE>
class AreaHeader 
    attr area_link         #用于full_list或者是free_list
    attr max_page_nu       #总共可分配的页的数量
    attr alloced_page_nu   #已分配页的数量
    attr free_pos          #指向下一页的地址
    attr free_page_list    #空闲页链表
end
</PRE>
当创建一个AreaHeader需要计算出它可分配页的最大数量，free_pos从域的起始地起开始，指向第一个页对齐的起地址。其它属性则被初始化空或者0。可分配的最大数量的计算公式为：
<BR><P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<!-- MATH
 \begin{displaymath}
\frac{AreaSize}{PageSize}-1
\end{displaymath}
 -->

<IMG
 WIDTH="20" HEIGHT="12" BORDER="0"
 SRC="img8.png"
 ALT="\begin{displaymath}\frac{AreaSize}{PageSize}-1\end{displaymath}">
</DIV>
<BR CLEAR="ALL">
<P></P>
从AreaHeader中每配一页的算法为：<PRE>
AreaHeader.AllocPage()
    if free_page_list.not_empty()   #如果free_page_list不为空
        page = free_page_list.take_front()  #则从free_page_list中取出
    else
        page=free_pos               #在Area中划分出一页
        free_pos+=PageSize          #更新free_pos的位置
    end 
    alloced_page_nu+=1              #更新已分配页的数量
    return page                     #返回页
end
</PRE>
MemBase的AllocPage算法保证，不向没有空闲页的area中分配页。 把页归还 AreaHeader 算法为：<PRE>
AreaHeader.FreePage(page)
    free_page_list.add_front(page)
    alloced_page_nu-=1
end
</PRE>

<P>
<BR><HR>
<ADDRESS>
NosicLin
2012-06-03
</ADDRESS>
</BODY>
</HTML>
