<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>字节码转换框架</TITLE>
<META NAME="description" CONTENT="字节码转换框架">
<META NAME="keywords" CONTENT="index">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="index.css">

<LINK REL="next" HREF="node8.html">
<LINK REL="previous" HREF="node6.html">
<LINK REL="up" HREF="index.html">
<LINK REL="next" HREF="node8.html">
</HEAD>

<BODY >

<DIV CLASS="navigation"><!--Navigation Panel-->
<A NAME="tex2html250"
  HREF="node8.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html248"
  HREF="index.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html242"
  HREF="node6.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A>   
<BR>
<B> Next:</B> <A NAME="tex2html251"
  HREF="node8.html">虚拟机</A>
<B> Up:</B> <A NAME="tex2html249"
  HREF="index.html">index</A>
<B> Previous:</B> <A NAME="tex2html243"
  HREF="node6.html">基本语句</A>
<BR>
<BR></DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL CLASS="ChildLinks">
<LI><A NAME="tex2html252"
  HREF="node7.html#SECTION00071000000000000000">常量</A>
<LI><A NAME="tex2html253"
  HREF="node7.html#SECTION00072000000000000000">变量</A>
<LI><A NAME="tex2html254"
  HREF="node7.html#SECTION00073000000000000000">数组</A>
<LI><A NAME="tex2html255"
  HREF="node7.html#SECTION00074000000000000000">散列表</A>
<LI><A NAME="tex2html256"
  HREF="node7.html#SECTION00075000000000000000">一元运算符</A>
<LI><A NAME="tex2html257"
  HREF="node7.html#SECTION00076000000000000000">下标运算符()</A>
<LI><A NAME="tex2html258"
  HREF="node7.html#SECTION00077000000000000000">下标运算符[ ]</A>
<LI><A NAME="tex2html259"
  HREF="node7.html#SECTION00078000000000000000">下标运算符 . </A>
<LI><A NAME="tex2html260"
  HREF="node7.html#SECTION00079000000000000000">二元运算符</A>
<LI><A NAME="tex2html261"
  HREF="node7.html#SECTION000710000000000000000">逻辑运算符AND</A>
<LI><A NAME="tex2html262"
  HREF="node7.html#SECTION000711000000000000000">逻辑运算符OR</A>
<LI><A NAME="tex2html263"
  HREF="node7.html#SECTION000712000000000000000">表达式语句</A>
<LI><A NAME="tex2html264"
  HREF="node7.html#SECTION000713000000000000000">直接赋值语句</A>
<LI><A NAME="tex2html265"
  HREF="node7.html#SECTION000714000000000000000">运算并赋值语句</A>
<LI><A NAME="tex2html266"
  HREF="node7.html#SECTION000715000000000000000">print语句</A>
<LI><A NAME="tex2html267"
  HREF="node7.html#SECTION000716000000000000000">for语句</A>
<LI><A NAME="tex2html268"
  HREF="node7.html#SECTION000717000000000000000">while语句</A>
<LI><A NAME="tex2html269"
  HREF="node7.html#SECTION000718000000000000000">if-elif-else语句</A>
<LI><A NAME="tex2html270"
  HREF="node7.html#SECTION000719000000000000000">break语句</A>
<LI><A NAME="tex2html271"
  HREF="node7.html#SECTION000720000000000000000">continue语句</A>
<LI><A NAME="tex2html272"
  HREF="node7.html#SECTION000721000000000000000">return语句</A>
<LI><A NAME="tex2html273"
  HREF="node7.html#SECTION000722000000000000000">函数定义语句</A>
<LI><A NAME="tex2html274"
  HREF="node7.html#SECTION000723000000000000000">类定义语句</A>
<LI><A NAME="tex2html275"
  HREF="node7.html#SECTION000724000000000000000">import语句</A>
<LI><A NAME="tex2html276"
  HREF="node7.html#SECTION000725000000000000000">export语句</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION00070000000000000000">
字节码转换框架</A>
</H1>
Codger解析器加载源程序时，前先对源程序进行词法分析，词别出由字符序列组成的单词，接着把单词交给语法分析模块处理。语法分析模块会生与源程序等价的抽象语法树，交给字节码转换模块。字节码转换模块负责根据抽象语法树生成字节码。

<P>
抽象语法树（abstract syntax tree，AST）是源代码的抽象语法结构的树状表示，它并不依赖于源语言的语法，树上的每个节点都表示源代码中的一种结构，这所以说是抽象的，是因为抽象语法树并不会表示出真实语法出现的每一个细节，比如说，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现。

<P>
Codger字节码转换算法采递归的形式把抽象语法树转换成字节码。语法树的每个节点实现了方法getopocde，当父节点getopcode方法被调用时，它会依次调用子节点的getopcode方法得到子节点的字节码，最后把所有子节点的字节码加工后返回。例如：a+b*c生成抽象语法后(如图<A HREF="#fig:abs_tree2"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>)得到根节点root,根节点root指向节点plus，节点plus有两个子节点，左节点为variable_a，右节点为mul。当plus的 getopcode 被调用时，plus会先调用左节点variable_a的 getopcode 方法得到左节点的字节码，然后调用右节点mul的 getopcode 方法得到右节点的字节码，最后把两个字节码加在一起，在后面增加一条OP_PLUS，如下图：<PRE>
+-----------+--------------+-------+
|左节点字节码| 右节点字节码 |OP_PLUS|
+ ----------+--------------+-------+
</PRE>
每种类型的节点有3种不同类型的转换：取值转换，赋值转换，运算并赋值转换。

<OL>
<LI>取值转换表示取当前节点的值，也就是上面谈到的getopcode方法，每个节点必须实现这种转换方式。
</LI>
<LI>赋值转换用于直接赋值语句中，表示对该节点赋值，这种转换方式为可选。例如：语句 a=a 生成抽象语法树后有两个节点，虽然左节点和右节点的类型相同，但它们的转换方式却不同，左节点赋值转换，右节点却为取值转换。
</LI>
<LI>运算并赋值转换转换，用于运算并赋值语句中，这种转换方式为可选。
</LI>
</OL>
在实现在算法时，为了尽量减少动态内存的分配，每次先分配一块大的内存，该内存在转换时被所有的节点共享，父节点告诉子节点从那里开始写入它的转换后的字节码，这种方法能提高整个转换算法性能，这也时Codger采用的方法。

<DIV ALIGN="CENTER"><A NAME="fig:abs_tree2"></A><A NAME="645"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure:</STRONG>
抽象语法树 a+b*c</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">

</DIV> <IMG
  WIDTH="314" HEIGHT="206" ALIGN="BOTTOM" BORDER="0"
 SRC="./abs_tree2.png"
 ALT="Image abs_tree2"></TD></TR>
</TABLE>
</DIV>

<P>
下面的部分会依次介始每一种类型的节点，它转换字节码的框架。被<code>&lt;  &gt;</code>的内容表示这是一个节点，例如图<A HREF="#fig:abs_tree2"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>节点plus，它有两个子节点，在表示时用<code>&lt;节点名&gt;</code>，为了保持整体的可读性，一条语句的所有信息都会出现。节点plus用后面的表示法为：<PRE>
&lt;expr1&gt; + &lt;expr2&gt;
</PRE>
其中<code>&lt;expr1&gt;</code>表示左节点，<code>&lt;expr2&gt;</code>表示右节点，它被转换后的字节码表示为:<PRE>
{
    expr1
}
{
    expr2
}
OP_PLUS
</PRE>
大括号表示调用子节点的getopcode方法。从上到下表示转换过后的字节码的排列顺序，节点expr1排在最前面，所以它在上面，最以OP_PLUS结尾。

<P>

<H2><A NAME="SECTION00071000000000000000">
常量</A>
</H2>
常量用LITERAL表示，转换成字节码为：<PRE>
OP_LOAD_CONST $(id)
</PRE>
其中
<BLOCKQUOTE>
id=MayConst(LITERAL)

</BLOCKQUOTE>
MapConst把LITERAL放入常量池中，并返回索引该LITERAL的id号。常量池是一位数组，id号是在数组中存LITERAL的位置。

<P>

<H2><A NAME="SECTION00072000000000000000">
变量</A>
</H2>

<OL>
<LI>获当前作用的变量identifier，转换成字节码为：<PRE>
OP_LOAD_SYMBOL $(id)
</PRE>
其中
<BLOCKQUOTE>
id=MaySymbol(identifier)

</BLOCKQUOTE>
MapSymbol把identifier放入符号池中，并返回索引该identifier的id号。符号池是一位数组，id号是在数组中存identifier的位置。

<P>
</LI>
<LI>在上层作用域查找变量，如果上层作用域没有找到该变量，则到上层的上层作用域中查找，并依次下去，语句形式：
<BLOCKQUOTE>
<code>$identifier</code>

</BLOCKQUOTE>
转换在字节码为：<PRE>
OP_LOAD_U_SYMBOL $(id)
</PRE>
其中
<BLOCKQUOTE>
id=MaySymbol(identifier)

</BLOCKQUOTE>
</LI>
</OL>

<P>

<H2><A NAME="SECTION00073000000000000000">
数组</A>
</H2>
语句形式：<PRE>
[ &lt;expr1&gt;, ... , &lt;exprn&gt; ]
</PRE>
省略号表示expr节点类型有n(<code>n&gt;=0</code>)个，n的值需要根据源程序来能确定，转换成字节码为：<PRE>
OP_ARRAY_BEGIN
{
    expr1
}
OP_ARRAY_PUSH
   ...
{
    exprn
}
OP_ARRAY_PUSH
</PRE>

<P>

<H2><A NAME="SECTION00074000000000000000">
散列表</A>
</H2>
语句形式：<PRE>
{ &lt;expr_key1&gt; -&gt; &lt;expr_value1&gt; , ... ,&lt;expr_keyn&gt; -&gt; &lt;expr_valuen&gt; }
</PRE>
其中<code>n&gt;=0</code>，转换成字节码为：<PRE>
OP_HASH_BEGIN
{
    expr_value1
}
{
    expr_key1
}
OP_HASH_MAP
    ...
{
    expr_valuen
}
{
    expr_keyn
}
OP_HASH_MAP
</PRE>

<P>

<H2><A NAME="SECTION00075000000000000000">
一元运算符</A>
</H2>
语句形式：<PRE>
unary_oper &lt;expr&gt;
</PRE>
转换成字节码为：<PRE>
{
    expr
}
OP_$(UNARY_OPER)
</PRE>
大括号表示需要根据expr的具体类型来转换字节码，$(UNARY_OPER)表示变量，它的值根据unary_oper来确定：
<BLOCKQUOTE>
1) 当unary_oper 为 + 时，UNARY_OPER 的值为 POSITIVE 
<BR>
2) 当unary_oper 为 - 时，UNARY_OPER 的值为 NEGATIVE 
<BR>
3) 当unary_oper 为 <code>~</code> 时，UNARY_OPER 的值为 NEGATED 
<BR>
4) 当unary_oper 为 not 时，UNARY_OPER 的值为 LOGIC_NOT

</BLOCKQUOTE>

<P>

<H2><A NAME="SECTION00076000000000000000">
下标运算符()</A>
</H2>
语句形式：<PRE>
expr ( &lt;expr1&gt; , ... , &lt;exprn&gt; )
</PRE>
其中n<code>&gt;</code>=0, 转换成字节码为：<PRE>
{
    expr
}
OP_ARRAY_BEGIN
{
    expr1
}
OP_ARRAY_PUSH
   ...
{
    exprn
}
OP_ARRAY_PUSH
OP_$(BRACKET)
</PRE>
其中:<PRE>
1)当expr以成员访问结束时，例如circle.area()，BRACKET的值为CALL_WITH_HOST
2)其它的情况下，例如 cos(3)， BRACKET 的值为 CALL
</PRE>
<H2><A NAME="SECTION00077000000000000000">
下标运算符[ ]</A>
</H2>
语句形式：<PRE>
&lt;expr&gt; [ &lt;expr1&gt; ]
</PRE>
转换成字节码为：<PRE>
{
    expr
}
{
    expr1
}
OP_GET_ITEM
</PRE>

<P>

<H2><A NAME="SECTION00078000000000000000">
下标运算符 . </A>
</H2>
语句形式：<PRE>
&lt;expr&gt; . &lt;identifier&gt;
</PRE>
转换成字节码为：<PRE>
{
    expr
}
OP_GET_ATTR $(id)
</PRE>
如果运算符 . 号后面紧跟 运算符 () ，则字节码转换为:<PRE>
{
    expr
}
OP_DUP_DATA1
OP_GET_ATTR $(id)
</PRE>

<P>
其中:
<BLOCKQUOTE>
id=MapSymbol(identifier)

</BLOCKQUOTE>

<P>

<H2><A NAME="SECTION00079000000000000000">
二元运算符</A>
</H2>
语句形式：<PRE>
&lt;expr_left&gt; binary_oper &lt;expr_right&gt;
</PRE>
转换成字节码为：<PRE>
{
    expr_left
}
{
    expr_right
}
OP_$(BINARY_OPER)
</PRE>
其中：<PRE>
1)当binary_oper 为 * 时， BINARY_OPER 的值为 MUL
2)当binary_oper 为 / 时， BINARY_OPER 的值为 DIV 
3)当binary_oper 为 % 时， BINARY_OPER 的值为 MOD 
4)当binary_oper 为 + 时， BINARY_OPER 的值为 PLUS 
5)当binary_oper 为 - 时， BINARY_OPER 的值为 MINUS
6)当binary_oper 为 &lt;&lt; 时， BINARY_OPER 的值为 LSHIFT
7)当binary_oper 为 &gt;&gt; 时， BINARY_OPER 的值为 RSHIFT
8)当binary_oper 为 &amp; 时， BINARY_OPER 的值为 AND
9)当binary_oper 为 ^ 时， BINARY_OPER 的值为 XOR
10)当binary_oper 为 | 时， BINARY_OPER 的值为 OR
11)当binary_oper 为 &lt; 时， BINARY_OPER 的值为 LT
12)当binary_oper 为 &lt;= 时， BINARY_OPER 的值为 LE
13)当binary_oper 为 == 时， BINARY_OPER 的值为 EQ
14)当binary_oper 为 != 时， BINARY_OPER 的值为 NE
15)当binary_oper 为 &lt;= 时， BINARY_OPER 的值为 GE
16)当binary_oper 为 &lt; 时， BINARY_OPER 的值为 GT
</PRE>

<P>

<H2><A NAME="SECTION000710000000000000000">
逻辑运算符AND</A>
</H2>
语句形式：<PRE>
&lt;expr_left&gt; and &lt;expr_right&gt;
</PRE>
转换成字节码为：<PRE>
{
    expr_left
}
OP_DUP_DATA1
OP_JUMPR_FALSE_FORWARD  $(End)
OP_DISCARD
{
    expr_right
}
@label End
</PRE>
其中$(End)表示OP_JUMPR_FALSE_FORWARD 跳转的相对地址,@lable End 用于标识指令的位置。

<P>

<H2><A NAME="SECTION000711000000000000000">
逻辑运算符OR</A>
</H2>
语句形式：<PRE>
&lt;expr_left&gt; or &lt;expr_right&gt;
</PRE>
转换成字节码为：<PRE>
{
    expr_left
}
OP_DUP_DATA1
OP_JUMPR_TRUE_FORWARD  $(End)
OP_DISCARD
{
    expr_right
}
@label End
</PRE>

<P>

<H2><A NAME="SECTION000712000000000000000">
表达式语句</A>
</H2>
语句形式:
<BLOCKQUOTE>
<code>&lt;expr&gt;</code>

</BLOCKQUOTE>
转换成字节码为：<PRE>
{
    expr
}
OP_DISCARD
</PRE>

<P>

<H2><A NAME="SECTION000713000000000000000">
直接赋值语句</A>
</H2>
赋值语句有左节点和右节点，左节点为被赋值的对象，转换方式为赋值转换；右节点的转换方式为取值转换。
语句形式：<PRE>
&lt;expr1&gt; = &lt;expr2&gt;
</PRE>
转换成字节码为：<PRE>
{
    expr2
}
{
    expr1
}
</PRE>
其中expr1为赋值转换，它有下面的几种情况：

<P>

<OL>
<LI>给变量赋值，语句形式：<PRE>
&lt;identifier&gt; = &lt;expr&gt;
</PRE>
转换成字节码为：<PRE>
{
   expr
}
OP_STORE_SYMBOL $(id)
</PRE>
其中:
<BLOCKQUOTE>
id=MapSymbol(identifier)

</BLOCKQUOTE>
</LI>
<LI>给上层作用域的变量赋值，如果上层作用域没有找到该变量，则到上层的上层作用域中查找，并依次下去，语句形式：<PRE>
&lt;$identifier&gt; = &lt;expr&gt;
</PRE>
转换成字节码为：<PRE>
{
   expr
}
OP_STORE_U_SYMBOL $(id)
</PRE>
其中:
<BLOCKQUOTE>
id=MapSymbol(identifier)

</BLOCKQUOTE>
</LI>
<LI>给集合指令的元素赋值，语句形式<PRE>
&lt;expr&gt; [ &lt;expr1&gt; ] = &lt;expr2&gt;
</PRE>
转换成字节码为：<PRE>
{
    expr2
}
{
    expr  
}
{
    expr1
}
OP_SET_ITEM
</PRE>
</LI>
<LI>给对象的成员赋值，语句形式<PRE>
&lt;expr&gt; . &lt;identifier&gt; = &lt;expr1&gt;
</PRE>
转换成字节码为：<PRE>
{
    expr1
}
{
    expr  
}
OP_SET_ATTR $(id)
</PRE>
其中:
<BLOCKQUOTE>
id=MapSymbol(identifier)

</BLOCKQUOTE>
</LI>
</OL>

<P>

<H2><A NAME="SECTION000714000000000000000">
运算并赋值语句</A>
</H2>
运算并赋值语句和赋值语句一样有两上节点，左节点为运算并赋值转换，右节点为取值转换，左节点的类型有以下几种情况:

<OL>
<LI>变量运算并赋值，语句形式：<PRE>
&lt;identifier&gt; assign_oper &lt;expr&gt;
</PRE>
转换成字节码为：<PRE>
{
    expr 
}
OP_LOAD_SYMBOL  $(id)
OP_DATA_SWAP0_1
OP_$(OPER)
OP_STORE_SYMBOL $(id)
</PRE>
其中：<PRE>
id=MapSymbol(identifier)

1)当assign_oper 为 *= 时， OPER 的值为 MUL
2)当assign_oper 为 /= 时， OPER 的值为 DIV 
3)当assign_oper 为 %= 时， OPER 的值为 MOD 
4)当assign_oper 为 += 时， OPER 的值为 PLUS 
5)当assign_oper 为 -= 时， OPER 的值为 MINUS
6)当assign_oper 为 &lt;&lt;= 时，OPER 的值为 LSHIFT
7)当assign_oper 为 &gt;&gt;= 时，OPER 的值为 RSHIFT
8)当assign_oper 为 &amp;= 时， OPER 的值为 AND
9)当assign_oper 为 ^= 时， OPER 的值为 XOR
10)当assign_ope 为 |= 时， OPER 的值为 OR
</PRE>
</LI>
<LI>当前作用域以上的变量运算并赋值，语句形式：<PRE>
&lt;$identifier&gt; assign_oper  &lt;expr&gt;
</PRE>
转换成字节码为：<PRE>
{
    expr 
}
OP_LOAD_U_SYMBOL  $(id)
OP_DATA_SWAP0_1
OP_$(OPER)
OP_STORE_U_SYMBOL $(id)
</PRE>
其中：<PRE>
id=MapSymbol(identifier)
</PRE>
OPER与assign_oper的关系见变量的运算并赋值
</LI>
<LI>与集中的指定的元素运算并赋值，语句形式：<PRE>
&lt;expr&gt; [ &lt;expr1&gt; ] assign_oper &lt;expr2&gt;
</PRE>
转换成字节码为：<PRE>
{
    expr2
}
{
    expr 
}
{
    expr1
}
OP_DUP_DATA3
OP_GET_ITEM
OP_DATA_SWAP0_1
OP_$(OPER)
OP_DATA_SWAP0_3
OP_DISCARD
OP_SET_ITEM
</PRE>
其中OPER 与assign_oper的关系见变量的运算并赋值。

<P>
</LI>
<LI>和对象的成员运算并赋值，语句形式：<PRE>
&lt;expr&gt; . &lt;identifier&gt; assign_oper &lt;expr1&gt;
</PRE>
转换成字节码为：<PRE>
{
    expr1
}
{
    expr 
}
OP_DUP_DATA2
OP_GET_ATTR $(id)
OP_DATA_SWAP0_1
OP_$(OPER)
OP_DATA_SWAP0_2
OP_DISCARD
OP_SET_ATTR $(id)
</PRE>
其中：<PRE>
id=MapSymbol(identifier)
</PRE>
OPER 与assign_oper的关系见变量的运算并赋值。
</LI>
</OL>

<P>

<H2><A NAME="SECTION000715000000000000000">
print语句</A>
</H2>
语句形式：<PRE>
print &lt;expr1&gt; , ... , &lt;exprn&gt;
</PRE>
其中<code>n&gt;=0</code>，转换成字节码为：<PRE>
{
    expr1
}
OP_PRINT
   ...
{
    exprn
}
OP_PRINT
OP_PRINT_LN
</PRE>

<P>

<H2><A NAME="SECTION000716000000000000000">
for语句</A>
</H2>
语句形式：<PRE>
for &lt;expr&gt; in &lt;expr1&gt;
    &lt;stmts&gt;
end
</PRE>
转换成字节码为：<PRE>
{
    expr1
}
OP_ITER
@lable Begin
OP_ITE_NEXT
OP_JUMPR_FORWARD $(End)
{
    expr
}
{
    stmts
}
OP_JUMPR_BACK $(Begin)
@label End
OP_DISCARD
</PRE>
其中expr语句为赋值转换，它的几种情况见直接赋值语句部分。最后需要更新stmts中的OP_BREAK与OP_CONTINUE指令<PRE>
Update OP_BREAK to OP_JUMPR_FORWARD $(End)
Update OP_CONTINUE to OP_JUMPR_BACK $(Begin)
</PRE>

<P>

<H2><A NAME="SECTION000717000000000000000">
while语句</A>
</H2>
语句形式：<PRE>
while &lt;expr&gt;
    &lt;stmts&gt;
end
</PRE>
转换成字节码为：<PRE>
@label Begin
{
    expr
}
OP_JUMPR_FALSE_FORWARD $(End)
{
    stmts
}
OP_JUMPR_BACK $(Begin)
@label End
</PRE>
最后需要更新stmts中的OP_BREAK和OP_CONTINUE 指令<PRE>
Update OP_BREAK to OP_JUMPR_FORWARD $(End)
Update OP_CONTINUE to OP_JUMPR_BACK $(Begin)
</PRE>

<P>

<H2><A NAME="SECTION000718000000000000000">
if-elif-else语句</A>
</H2>
语句形式：<PRE>
if &lt;expr1&gt;
   &lt;stmts1&gt;
elif &lt;expr2&gt;
   &lt;stmts2&gt;
elif 
    ....
else 
   &lt;stmtsn&gt;
end
</PRE>
其中<code>n&gt;=0</code>，转换成字节码为：<PRE>
{
    expr1
}
OP_JUMPR_FALSE_FORWARD $(L1)
{
    stmts1
}
OP_JUMPR_FORWARD $(End)
@label L1
{
    expr2
}
OP_JUMPR_FALSE_FORWARD $(L2)
{
    stmts2
}
OP_JUMPR_FORWARD $(End)
@label L2
    .....

@lable Ln
{
    stmtsn
}
@label End
</PRE>
如果else部分不存在，则去掉字节码中stmtsn的部分。

<P>

<H2><A NAME="SECTION000719000000000000000">
break语句</A>
</H2>
语句形式：
<BLOCKQUOTE>
break

</BLOCKQUOTE>
转换成字节码为：
<BLOCKQUOTE>
OP_BREAK 

</BLOCKQUOTE>
指令OP_BREAK只是用于辅助字节码的生成，它最终会被替换为OP_JUMPR*

<P>

<H2><A NAME="SECTION000720000000000000000">
continue语句</A>
</H2>
语句形式：
<BLOCKQUOTE>
continue 

</BLOCKQUOTE>
转换在字节码为：
<BLOCKQUOTE>
OP_CONTINUE 

</BLOCKQUOTE>
指令OP_CONTINUE只是用于辅助字节码的生成,它最终会被替换为OP_JUMPR*

<P>

<H2><A NAME="SECTION000721000000000000000">
return语句</A>
</H2>

<OL>
<LI>return后跟一个表达式，语句形式：
<BLOCKQUOTE>
<code>return &lt;expr&gt;</code>

</BLOCKQUOTE>
转换成字节码为：<PRE>
{
    expr
}
OP_RETURN
</PRE>

<P>
</LI>
<LI>return后不跟表达式,语句形式：
<BLOCKQUOTE>
return 

</BLOCKQUOTE>
转换成字节码为：
<BLOCKQUOTE>
OP_RETURN_NIL

</BLOCKQUOTE>
</LI>
</OL>

<P>

<H2><A NAME="SECTION000722000000000000000">
函数定义语句</A>
</H2>

<OL>
<LI>有名函数，语句形式为：<PRE>
func &lt;identifier&gt;( &lt;id_simply1&gt;, ... ,&lt;id_simplyn&gt;,
                 &lt;id_def&gt; = &lt;expr1&gt;, ... , &lt;id_defm&gt; = &lt;exprm&gt;,
                 &lt;*id_many&gt; )
      &lt;stmts&gt;
end
</PRE>
其中<code>n&gt;=0,m&gt;=0</code>, 解析时，根据stmts，参数个类，及参数类型，生成新的字节码 op_code 
<BR>转换成字节码为：<PRE>
OP_FUNC_BEGIN $(op_id)
OP_ARRAY_BEGIN
{
    expr1
}
OP_ARRAY_PUSH
   .....
{
    exprm
}
OP_ARRAY_PUSH
OP_FUNC_DEFALUT_ARGS
OP_DUP_DATA1
OP_STORE_SYMBOL  $(name_id)
</PRE>
其中：<PRE>
op_id=MapOpcode(op_code) 
name_id=MapSymbol(identifier)
</PRE>
</LI>
<LI>匿名函数与有名函数的转换过程相同，但少了最后两个 OP_DUP_DATA1 与 OP_STORE_SYMBOL 指令
</LI>
</OL>

<P>

<H2><A NAME="SECTION000723000000000000000">
类定义语句</A>
</H2>
语句形式：<PRE>
class &lt;identifier&gt; 
    &lt;class_stmt1&gt;
        ...
    &lt;class_stmtn&gt;
end
</PRE>
其中<code>n&gt;=0</code>,
转换成字节码为：<PRE>
OP_CLASS_BEGIN
{
    class_stmt1
}
   .....
{
    class_stmtn
}
OP_STORE_SYMBOL $(id)
</PRE>
其中:
<BLOCKQUOTE>
id=MapSymbol(identifier)

</BLOCKQUOTE>
class_stmt有以下几种形式：

<OL>
<LI>属性申明语句(不带默认值)：<PRE>
&lt;perm&gt; &lt;static&gt; attr &lt;identifier&gt;
</PRE>
转换成字节码为：<PRE>
OP_LOAD_NIL
OP_CLASS_$(TEMP) $(id)
</PRE>
其中:：<PRE>
id=MapPermSymbol(identifier,perm)
1)如果static不存在，则TEMP=TEMPLATE
2)如果static存在，则TEMP=ATTR
</PRE>
perm的值为可以为public,protected,private；如果在申明时没说明权限， perm 默认为protected。 MapPermSymbol 把 identifier 放入带权限的符号池中，在identifier 中保存权限信息，并返回索引该 identifier 的 id 号。带权限的符号池是一位数组，id号是在数组中存 identifier 的位置。

<P>
</LI>
<LI>属性申明语句(带默认值)：<PRE>
&lt;perm&gt; &lt;static&gt; attr &lt;identifier&gt;  = &lt;expr&gt;
</PRE>
转换成字节码为：<PRE>
{
    expr
}
OP_CLASS_$(TEMP) $(id)
</PRE>
其中：<PRE>
id=MapPermSymbol(identifier,perm)
1)如果static不存在，则TEMP=TEMPLATE
2)如果static存在，则TEMP=ATTR
</PRE>

<P>
</LI>
<LI>方法申明语句：<PRE>
&lt;perm&gt; &lt;static&gt; func &lt;identifier&gt;( &lt;id_simply1&gt;, ... ,&lt;id_simplyn&gt;,
                 &lt;id_def&gt; = &lt;expr1&gt;, ... , &lt;id_defm&gt; = &lt;exprm&gt;,
                 &lt;*id_many&gt; )
      &lt;stmts&gt;
end
</PRE>
其中<code>n&gt;=0,m&gt;=0</code>, 解析时，根据stmts，参数个类，及参数类型，生成新的字节码 op_code 
<BR>转换成字节码为：<PRE>
OP_FUNC_BEGIN $(op_id)
OP_ARRAY_BEGIN
{
    expr1
}
OP_ARRAY_PUSH
   .....
{
    exprm
}
OP_ARRAY_PUSH
OP_FUNC_DEFALUT_ARGS
OP_CLASS_$(TEMP)  $(name_id)
</PRE>
其中：<PRE>
name_id=MapPermSymbol(identifier , perm)
op_id=MapOpcode(op_code) 
1)如果static不存在，则TEMP=TEMPLATE
2)如果static存在，则TEMP=ATTR
</PRE>
</LI>
</OL>

<P>

<H2><A NAME="SECTION000724000000000000000">
import语句</A>
</H2>

<OL>
<LI>语句形式：<PRE>
import &lt;identifier1&gt; . ~~~ . &lt;identifiern&gt;
</PRE>
由于省略号与点号会混淆，所以用<code>~~~</code>中当存在多个标识符，其中<code>n&gt;=1</code> 
<BR>转换成字节码为：<PRE>
OP_IMPORT $(idx)
OP_STORE_SYMBOL $(id1)
</PRE>
其中:<PRE>
idx=MapSymbol(identifier1.~~~.identifiern)
id1=MapSymbol(identifier)
</PRE>

<P>
</LI>
<LI>语句形式：<PRE>
import &lt;identifier1&gt; . ~~~ . &lt;identifiern&gt; as &lt;identifierm&gt;
</PRE>
其中<code>n&gt;=1</code>， 转换成字节码为：<PRE>
OP_IMPORT $(idx)
OP_STORE_SYMBOL $(idm)
</PRE>
其中:<PRE>
idx=MapSymbol(identifier1.~~~.identifiern)
idm=MapSymbol(identifierm)
</PRE>
</LI>
</OL>

<P>

<H2><A NAME="SECTION000725000000000000000">
export语句</A>
</H2>

<OL>
<LI>语句形式：<PRE>
export &lt;identifier&gt;
</PRE>
转换成字节码为：<PRE>
OP_LOAD_SYMBOL $(id)
OP_EXPORT $(id)
</PRE>
其中：<PRE>
id=MapSymbol(identifier)
</PRE>

<P>
</LI>
<LI>语句形式：<PRE>
export &lt;expr&gt;  as &lt;identifier&gt;
</PRE>
转换成字节码为：<PRE>
{
    expr
}
OP_EXPORT $(id)
</PRE>
其中：<PRE>
id=MapSymbol(identifier)
</PRE>

<P>
</LI>
</OL>

<P>

<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A NAME="tex2html250"
  HREF="node8.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html248"
  HREF="index.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html242"
  HREF="node6.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A>   
<BR>
<B> Next:</B> <A NAME="tex2html251"
  HREF="node8.html">虚拟机</A>
<B> Up:</B> <A NAME="tex2html249"
  HREF="index.html">index</A>
<B> Previous:</B> <A NAME="tex2html243"
  HREF="node6.html">基本语句</A></DIV>
<!--End of Navigation Panel-->
<ADDRESS>
NosicLin
2012-06-03
</ADDRESS>
</BODY>
</HTML>
