<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>状态机的合并</TITLE>
<META NAME="description" CONTENT="状态机的合并">
<META NAME="keywords" CONTENT="index">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="index.css">

<LINK REL="previous" HREF="node17.html">
<LINK REL="up" HREF="node14.html">
<LINK REL="next" HREF="node19.html">
</HEAD>

<BODY >

<DIV CLASS="navigation"><!--Navigation Panel-->
<A NAME="tex2html311"
  HREF="node19.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="/usr/share/latex2html/icons/next.png"></A> 
<A NAME="tex2html309"
  HREF="node14.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="/usr/share/latex2html/icons/up.png"></A> 
<A NAME="tex2html305"
  HREF="node17.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="/usr/share/latex2html/icons/prev.png"></A>   
<BR>
<B> Next:</B> <A NAME="tex2html312"
  HREF="node19.html">数据类型</A>
<B> Up:</B> <A NAME="tex2html310"
  HREF="node14.html">词法识别算法</A>
<B> Previous:</B> <A NAME="tex2html306"
  HREF="node17.html">识别算法</A>
<BR>
<BR></DIV>
<!--End of Navigation Panel-->

<H2><A NAME="SECTION00034000000000000000">
状态机的合并</A>
</H2>
在前面介绍过，状态链算法是一种分治的算法，其主要思想为先为每个不同类型的单词构造子状态机，然后通过合并算法把子状态机合并成为一个大的综合性的状态机。假设现在有两个状态机:
<BLOCKQUOTE>
1) 状态机A用于识别正则式[0-7]+abf所表示的语言，如图<A HREF="#fig:state_a"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/crossref.png"></A>
<BR>
2) 状态机B用于识别正则式[4-9]+acd所表示的语言，如图<A HREF="#fig:state_b"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/crossref.png"></A>

</BLOCKQUOTE>

<DIV ALIGN="CENTER"><A NAME="fig:state_a"></A><A NAME="133"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure:</STRONG>
状态机A</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">

</DIV> [scale=1]s_a.png</TD></TR>
</TABLE>
</DIV>

为了减少字符映射数组的使用，让状态机A的所有状态共享一个状态映射数组，这样一来，对于每个状态来说就有5种输入类型，同样也就有5个后继状态：
<BLOCKQUOTE>
1) 数字0到7，命名为 D0_7  
<BR>
2) 字符a，命名为 S_a  
<BR>
3) 字符b，命名为 S_b 
<BR>
4) 字符f，命名为 S_f 
<BR>
5) 除以上字符以外的所有字符，命名为 Other

</BLOCKQUOTE>
例如状态机A中的状态A1的后继状态为：[A1,A2,err,err,err] 

<P>
同样对状态机B中的所有状态也让它们共享一个状态映射数组，则对于每个状态来说，输入类型有5种，5个后继状态：
<BLOCKQUOTE>
1) 数字4到9，命名为 D4_9 
<BR>
2) 字符a，命名为 S_a 
<BR>
3) 字符c，命名为 S_c 
<BR>
4) 字符d, 命名为 S_d 
<BR>
5) 除以上字符以外的所有字符，命名为 Other

</BLOCKQUOTE>

<DIV ALIGN="CENTER"><A NAME="fig:state_b"></A><A NAME="142"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure:</STRONG>
状态机B</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">

</DIV> [scale=1]s_b.png</TD></TR>
</TABLE>
</DIV>

合并过程如下：
<DL>
<DT><STRONG>第一步:</STRONG></DT>
<DD>合并状态机A与状态B的输入类型，找出相交输入类型，提取出它们的公有子集，输入类型合并的有9种：
<BLOCKQUOTE>
1) 数字0到3, 命名为 D0_3 
<BR>
2) 数字4到7, 命名为 D4_7 
<BR>
3) 数字8到9, 命名为 D8_9 
<BR>
4) 字符a,  命名为 S_a 
<BR>
5) 字符b,  命名为 S_b 
<BR>
6) 字符c,  命名为 S_c 
<BR>
7) 字符d,  命名为 S_d 
<BR>
8) 字符f,  命名为 S_f 
<BR>
9) 除以上字符以外的所有字符, 命名为 Other

</BLOCKQUOTE>
其中状态机A中的输入类型D0_7被分解成为了输入类型D0_3和D4_7；状态机中的输入类型D4_9被分解成了输入类型D4_7和D8_9
</DD>
<DT><STRONG>第二步:</STRONG></DT>
<DD>状态机A的开始状态为Abegin，状态机B的开始状态为Bbegin，创建一个状态复合状态 {Abeign ,Bbegin}, 把该复合状态命名为Cbegin，并且标记Cbegin。其中复合状态的定义为：复合状态中的任意一个状态能在某种输入类型下发生状态转移，该复合状态也能在该输入类型下发生状态转移，并且后继状态相同。
</DD>
<DT><STRONG>第三步:</STRONG></DT>
<DD>找出一个被标记的复合状态，现在只有Cbeign被标记，所以取出 Cbegin，然后取消标记 Cbeign，并确定Cbegin的后继状态，Cbeign 为 {Abegin ,Bbegin} 的复合状态：
<BR>因为：<PRE>
f(Abegin,D0_7)-&gt;A1
f(Bbegin,D4_9)-&gt;B1
</PRE>
推出：<PRE>
f(Cbegin,D0_3)-&gt;A1
f(Cbegin,D4_7)-&gt;{A1,B1}
f(Cbegin,D8_9)-&gt;B1
</PRE>
CBegin的转换情况如下表<A NAME="tex2html6"
  HREF="footnode.html#foot156"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>:

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER">状态输入</TD>
<TD ALIGN="CENTER">D0_3</TD>
<TD ALIGN="CENTER">D4_7</TD>
<TD ALIGN="CENTER">D8_9</TD>
<TD ALIGN="CENTER">S_a</TD>
<TD ALIGN="CENTER">S_b</TD>
<TD ALIGN="CENTER">S_c</TD>
<TD ALIGN="CENTER">S_d</TD>
<TD ALIGN="CENTER">S_f</TD>
<TD ALIGN="CENTER">Other</TD>
</TR>
<TR><TD ALIGN="CENTER">CBegin</TD>
<TD ALIGN="CENTER">A1</TD>
<TD ALIGN="CENTER">A1,B1</TD>
<TD ALIGN="CENTER">B1</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
</TR>
</TABLE>

<P>
在确定后继状态，需要处理的其中的复合状态，Cbeign在输入事件D4_7下转移到复合状{A1,B1}，该复合状态以前并没出现过，创建复合状态{A1,B1}，把该状态命名为C1,标记C1。
</DD>
<DT><STRONG>第四步:</STRONG></DT>
<DD>检测现在是否存在被标记的复合状态，如果存在，跳转到第三步。如果没有，则状态机的合并完成。现在状态C1被标记，将其取出，取消标记C1，C1 为 {A1,B1} 的复合状态:
<BR>因为：<PRE>
f(A1,D0_7)-&gt;A1
f(A1,S_a)-&gt;A2
f(B1,D4_9)-&gt;B1
f(B1,S_a)-&gt;B2
</PRE>
推出：<PRE>
f(C1,D0_3)-&gt;A1
f(C1,D4_7)-&gt;{A1,B1}
f(C1,D8_9)-&gt;B1
f(C1,S_a)-&gt;{A2,B2}
</PRE>

<P>
C1的状态转移如下表:

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER">状态输入</TD>
<TD ALIGN="CENTER">D0_3</TD>
<TD ALIGN="CENTER">D4_7</TD>
<TD ALIGN="CENTER">D8_9</TD>
<TD ALIGN="CENTER">S_a</TD>
<TD ALIGN="CENTER">S_b</TD>
<TD ALIGN="CENTER">S_c</TD>
<TD ALIGN="CENTER">S_d</TD>
<TD ALIGN="CENTER">S_f</TD>
<TD ALIGN="CENTER">Other</TD>
</TR>
<TR><TD ALIGN="CENTER">C1</TD>
<TD ALIGN="CENTER">A1</TD>
<TD ALIGN="CENTER">A1,B1</TD>
<TD ALIGN="CENTER">B1</TD>
<TD ALIGN="CENTER">A2,B2</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
</TR>
</TABLE>

<P>
C1的后继中状态中有两个复合状态，其中复合状态{A1,B1}在以前已经被创建过，所以不对其进行处理。复合状态{A2,B2}以前没有出现过，则创建它，并且标记，把它命名为C2。

<P>
现在还存在标记的复合状态C2，所以继续按照每二步的方法来处理，取出C2，取消标记，C2为 {A2, B2} 的复合状态: 
<BR>因为：<PRE>
f(A2,S_b)=A3
f(B2,S_c)=B3
</PRE>
推出:<PRE>
f(C2,S_b)=A3
f(C2,S_c)=B3
</PRE>

<P>
C2的状态转移如下表：

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER">状态输入</TD>
<TD ALIGN="CENTER">D0_3</TD>
<TD ALIGN="CENTER">D4_7</TD>
<TD ALIGN="CENTER">D8_9</TD>
<TD ALIGN="CENTER">S_a</TD>
<TD ALIGN="CENTER">S_b</TD>
<TD ALIGN="CENTER">S_c</TD>
<TD ALIGN="CENTER">S_d</TD>
<TD ALIGN="CENTER">S_f</TD>
<TD ALIGN="CENTER">Other</TD>
</TR>
<TR><TD ALIGN="CENTER">C2</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">A3</TD>
<TD ALIGN="CENTER">B3</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
</TR>
</TABLE>
</DD>
</DL>

<P>
现在以经没有被标记过的状态，表示状态机的整个合并过程完成，合并后创建了3个新状态：CBegin, C1, C2。每个状态接受的输入类型有9个，但可以对其进行优化，因为三个状态在输入类型 S_d, S_f ,Other 下都转移到err，可以把它们合并到输入类型Other中，即最终的输入类型7个：
<BLOCKQUOTE>
1) 数字0到3, 命名为 D0_3 
<BR>
2) 数字4到7, 命名为 D4_7 
<BR>
3) 数字8到9, 命名为 D8_9 
<BR>
4) 字符a,  命名为 S_a 
<BR>
5) 字符b,  命名为 S_b 
<BR>
6) 字符c,  命名为 S_c 
<BR>
7) 除以上字符以外的所有字符, 命名为 Other

</BLOCKQUOTE>
合并后的状态图为：图<A HREF="#fig:state_c"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/crossref.png"></A>, 每个状态后继状态如下：
<BLOCKQUOTE>
1) CBegin后继状态为：[A1,C1,B1,err,err,err,err]  
<BR>
2) C1后继状态为：[A1,C1,B1,C2,err,err,err] 
<BR>
3) C2后继状态为:[err,err,err,err,A3,B3,err] 

</BLOCKQUOTE>

<DIV ALIGN="CENTER"><A NAME="fig:state_c"></A><A NAME="190"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure:</STRONG>
状态机A与状态机B后并后</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">

</DIV>[scale=0.8,angle=90]s_c.png</TD></TR>
</TABLE>
</DIV>

状态机A与状态B的合并过程中，并不会改变状态A与状态机B的任何一个状态的信息，合并后创建了3个的新状态。新状态通过后继状态链接到子状态机A与子状态机B中的状态。把识别算法中的开始状态改为Cbegin，就可以对正则式[0-7]+abf和[4-9]+acd表示的语言进行识别。因为子状态的数据没有被改变，当只需要识别正则式[0-7]+abf所表示的语言时，同样也只需要把识别算法中的开始状态改变Abegin即可，这种特性使模块的调试变得很简单，可以先测试子状态机A和子状态机B是否正确，然后再测试合并后的状态机是否正确。

<P>
在Codger词法中有9个不同类型的单词，关键字的识别是通用先识别出标识符，然后再判断标识符是否属于关键字。子状态机有8个，识别每种单词类型子状态机的开始符号所接受的输入事件类型之间的交集很少，例如：注释以#号开头，整数和以数字开头，浮点数以数字和点号开头，字符串以双引号开头，标识符以字母开头，在合并的时，涉及到的复合状态很少，最复杂的合并属于浮点数与整数的合并，但合并后也只创建了4个新的状态。

<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A NAME="tex2html311"
  HREF="node19.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="/usr/share/latex2html/icons/next.png"></A> 
<A NAME="tex2html309"
  HREF="node14.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="/usr/share/latex2html/icons/up.png"></A> 
<A NAME="tex2html305"
  HREF="node17.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="/usr/share/latex2html/icons/prev.png"></A>   
<BR>
<B> Next:</B> <A NAME="tex2html312"
  HREF="node19.html">数据类型</A>
<B> Up:</B> <A NAME="tex2html310"
  HREF="node14.html">词法识别算法</A>
<B> Previous:</B> <A NAME="tex2html306"
  HREF="node17.html">识别算法</A></DIV>
<!--End of Navigation Panel-->
<ADDRESS>
NosicLin
2012-06-03
</ADDRESS>
</BODY>
</HTML>
