\section{基本语句}
在Codger中，总共有16不同类型的语句，一个Codger源程序由一条或多条语句组成，语句与语句之间使用一个或者多个分隔符隔开，分隔符有两种：换行符和分号符。例如, 用换行符来分隔两条语句:
\begin{quote}
\begin{verbatim}
a=3
b=4
\end{verbatim}
\end{quote}
或者当需要把多条语句写到一行时，可以用分号来分隔语句，例如:
\begin{quote}
\begin{verbatim}
a=3;b=4
\end{verbatim}
\end{quote}
或者是使用类似于c风格的来分隔语句，例如:
\begin{quote}
\begin{verbatim}
a=3;
b=4; 
\end{verbatim}
\end{quote}
不同类型的语句有不同类型的语法规则，在源程只有遵守语法规则才会被解析器正确解析，Codger的语法分析模块使用bison\footnote{gnu发布的一款在linux平台下替代yacc的语法分析软件，bison完全兼容yacc}软件把描述Codger语法规则的LR(1)文法转换为LALR(1)分析表，来分析源程序的语法结构是否正确，最后生成与源程序等价的抽象语法树，以供后面的字节码生成模块进一步处理。

Codger中的16条语句被分为６类：简单语句，循环语句，选择语句，跳转语句，异常语句，定义语句，模块管理语句。下面部分依次介绍每类语句的语法规则。

\subsection{简单语句}
\subsubsection{表达式语句}
表达式在前面``表达式与算述符"这一部分已经介绍，如果一个表达式没有被其它语句使用，它的前后都有语句分隔符，在这种情况下，则被称为表达示语句，语法规则用文法表示为：
\begin{quote}
\begin{verbatim}
expr_stmt = expr 
\end{verbatim}
\end{quote}
表达式语句中，表达式会被运行，但表达式返回的结果没有其它对象引用，会被直接丢弃。\\
示例代码:
\begin{quote}
\begin{verbatim}
1+2         #计算的结果3被直丢弃
add(1+3)    #函数add返回结果4，被丢弃
\end{verbatim}
\end{quote}

\subsubsection{赋值语句}
赋值语句是给可赋值对象赋于一个值，Codger中可赋值对象有：变量，集合中的元素，对象的成员。赋值语句分为两类：1）直接赋值：将值直接赋值给可赋值对象；2）运算后再赋值：先从可赋值对象中提取出原有的值，并与将要赋的值进行指定的运算后，再赋值给可赋值对象。语法规则用文法表示为：
\begin{quote}
\begin{verbatim}
assign_stmt = assign_object assign_oper expr 
assign_oper =  "=" | "*=" | "/=" | "%=" | "+=" |
               "-=" | "<<=" | ">>=" | "&=" | "^=" | "|="
assign_object = identifier | "$" identifier |
                expr "[" expr "]" | expr "." identifier 
\end{verbatim}
\end{quote}
其中\$identifier表示变量identifier不在当前作用域，它告诉虚拟机在上层作用域到顶层作用域之间查找。\\
示例代码：
\begin{quote}
\begin{verbatim}
a=3+4     
$a=4      
coord.x=0.3
array[3]+=4
\end{verbatim}
\end{quote}
\subsubsection{print语句}
print语句用于将对象的值输出到标准输出端，语法规则用文法表示为：
\begin{quote}
\begin{verbatim}
print_stmt =  "print" [expr] { "," expr }
\end{verbatim}
\end{quote}
示例代码：
\begin{quote}
\begin{verbatim}
print 2                    #输出:  2
print "Codger"+"Is"+"Good" #输出:  "CodgerIsGood"
print 3+3,3+4,1+2          #输出:  6 7 3
a=[3,4,5]
print a                    #输出:  [3,4,5]
\end{verbatim}
\end{quote}



\subsection{循环语句}
\subsubsection{for语句}
for语句用于遍历可迭代对象中的每一个元素，Codger中的可迭代对象有数组和散列表。语法规则用文法表示为：
\begin{quote}
\begin{verbatim}
for_stmt = "for" assign_object "in" expr for_delimiter
                stmts
            "end"
for_delimiter = "\n" | ";" | "do"
\end{verbatim}
\end{quote}
在for语句运行时，每次从expr返回对象中取出一个元素，赋值给可赋值对象assign\_object，并执行语句stmts。当expr返回对象中的每个元素都被遍历完成时，for语句结束。\\
示例代码:
\begin{quote}
\begin{verbatim}
a=[3,4,5,5]
sum=0
for i in a
    sum+=i
end
print sum   #输出为17
\end{verbatim}
\end{quote}

\subsubsection{while语句}
while语句由一个控制表达式和子语句组成，while语句循环执行子语句中的内容，直到表达式的结果为假，语法规则文法表示为:
\begin{quote}
\begin{verbatim}
while_stmt = "while" expr while_delimiter
                  stmts
             "end"
while_delimiter = "\n" | ";" | "do"
\end{verbatim}
\end{quote}
示例代码:
\begin{quote}
\begin{verbatim}
i=0
sum=0
while i<=100
    sum+=i
    i+=1
end 
print sum  #输出为: 5050
\end{verbatim}
\end{quote}

\subsection{选择语句}
\subsubsection{if-elif-else语句}
if-elif-else语句由一个if部分，零个或多个elif部分，零个或一个else部分组成。if和elif部分由控制表达式和子语句组成，else部分由一个子语句组成。if-elif-else语句运行时，先从if部分开始判断控制表达式是否为真，如果为真，则执行if部分的子语句，并退出if-elif-else语句，如果为假，则会依次判断elif的控制表达式，elif的控制表达式如果为真，则执行相对应的elif的子语句，并退出if-elif-else语句。如果elif的控制表达式为假，则判断下一个elif部分。最后如果if-elif-else还没有退出，则执行else部分的语句。语法规则用文法表示为:
\begin{quote}
\begin{verbatim}
if_stmt = if_part  {elif_part} [else_part] "end"
if_part = "if" expr if_delimiter stmts 
elif_part = "elif" expr if_delimiter stmts
else_part = "else" stmts
if_delimiter = "\n" | ";" | "then"
\end{verbatim}
\end{quote}
示例代码：
\begin{quote}
\begin{verbatim}
a=2
if a==1
    print 1
elif a==2
    print 2
else 
    print "unkown"
end 
#输出为 2
\end{verbatim}
\end{quote}

\subsection{跳转语句}
\subsubsection{break语句}
break语句用于在循环语句中,当循环语句执行时，遇到break语句，则会退出循环，语法规则用文法表示为
\begin{quote}
\begin{verbatim}
break_stmt = "break" 
\end{verbatim}
\end{quote}
示例代码：
\begin{quote}
\begin{verbatim}
a=[1,2,3,4,5,6] 
sum=0
for i in a
    if a ==3
        break
    end 
    sum+=i
end 
print sum   #输出为: 3
\end{verbatim}
\end{quote}

\subsubsection{continue语句}
continue语句用于循环语句中，当循环语句执行时，遇到continue语句，则会放弃执行当前循环后面的内容，重新开始下一次循环,语法规则使用文法表示为
\begin{quote}
\begin{verbatim}
continue_stmt = "continue" 
\end{verbatim}
\end{quote}
示例代码
\begin{quote}
\begin{verbatim} 
i=0
sum=0
while i<10
    i+=1
    if i%2==0
        continue
    end 
    sum+=i
end 
print sum   #输出为: 25
\end{verbatim}
\end{quote}

\subsubsection{return语句}
return 语句用来终止一个函数的执行，并返回表达式的值。 如果表达式被省略，或在函数内没有执行return语句，则值Nil。当执行return语句时，即使函数体中仍然还有其他语句，此函数也会停止执行。语法规则使用文法表示为：
\begin{quote}
\begin{verbatim}
return_stmt = "return" [ expr ]
\end{verbatim}
\end{quote}
示例代码：
\begin{quote}
\begin{verbatim}
func add(x,y)
    return x+y
end 

print add(3,4)   #输出为7
\end{verbatim}
\end{quote}
\subsection{异常语句}
\subsubsection{throw语句}
生成一个可由 try-catch-finally 语句处理的错误或异常，语法规则用文法表示为：
\begin{quote}
\begin{verbatim}
throw_stmt = "throw" [ expr ]
\end{verbatim}
\end{quote}
示例代码：
\begin{quote}
\begin{verbatim}
print 3
throw Error("Some Error Happend")
print 4

#输出为:  3
#         Error: "Some Error Happend"
\end{verbatim}
\end{quote}


\subsubsection{try-catch-finally语句}
try-catch-finally语句提供一种机制，用于捕捉在块的执行期间发生的各种异常。此外try-finally-catch语句还能让您指定一个代码块，并保证当控制离开try语句时，先执行该代码。语法规则用文法表示为：
\begin{quote}
\begin{verbatim}
try_stmt = ( try_part finally_part  "end") |
           ( try_part [catch_part] {catch_part} 
                      [finally_part] "end" )
try_part = "try" try_demiliter stmts
catch_part = "catch" [expr] { "," expr } ["as" identifier]
             try_demiliter stmts
finally = "finally" try_demiliter stmts
try_demiliter = "\n"|";"
\end{verbatim}
\end{quote}
示例代码：
\begin{quote}
\begin{verbatim}
try 
    i=a   #变量a未定义，运行时会抛出NameError
catch NameError as e
    print "Catch "+e.name+"Not Defined"
end 
#输出为: "Catch a Not Defined"
\end{verbatim}

\end{quote}


\subsection{定义语句}
\subsubsection{函数定义语句}
函数定义语句见``数据类型--函数''那一部分
\subsubsection{类定义语句}
类定义语句见``数据类型--类''那一部分

\subsection{模块管理语句}
模块是Codger组织源文件的一个基本方式，每个源文件被加载完成时，虚拟机内部会生成一个模块对象用于表示该源文件。
\subsubsection{import语句}
import语句用于导入其它模块到当前模块中，语法规则用文法表示为
\begin{quote}
\begin{verbatim}
import_stmt ="import" identifier 
             {"." identifier} [ "as" identifier]
\end{verbatim}
\end{quote}
示例代码:
\begin{quote}
\begin{verbatim}
import math
print math.cos(math.pi)    #输出为: -1
\end{verbatim}
\end{quote}
\subsubsection{export语句}
export用于把当前模块的对象导出，供其它模块访问，使用语法规则用文法表示为:
\begin{quote}
\begin{verbatim}
export_stmt = ( "export" identifier ) |
              ( "export" expr "as" identifier )
\end{verbatim}
\end{quote}
示例代码：
\begin{quote}
\begin{verbatim}
func add(x,y)
    return x+y
end 
export add    #当被其它模块导入时，函数add可以被其它模块访问到
\end{verbatim}
\end{quote}













