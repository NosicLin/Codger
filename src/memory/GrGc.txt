[Garbage Collection Algrithom]


[堆块的数据结构与容量]
在Codger中，堆的大小是可以扩展，而不是固定的大小,堆的数据结构由一个一维的数组(Heap_Blocks)
组成，数组中的元素用于指向一页,在大多数平台下，页的大小为page_size=4k。假设当前
Heap_Blocks的有效长度为n，那么此时的堆容量为n*page_size.由于每一页的开头需要用一定的空间
来存储一些信息，所以实际上能分配出去的空间小于n*page_size。
--------------------------------------------------------------------------------
[堆块的数据结构]:
struct gc_heap
{
    struct gc_block_header** b_blocks;   #一维数组
    ssize_t b_cap;                       #一维数组的大小
    ssize_t b_size;                      #一维数组的有效长度
    struct gc_block_header* b_cur;       #当前分配页
};
    
[快照]
Block_Heap_Bottom                                    Block_Heap_Top
(b_blocks)                          (b_size)          (b_cap)  
 ----|----|----|----|----|........|----|----|----|.....|
  \      \                            \
 __\____  \ _______                  __\____ 
|       |  |       |                |       |  <--- b_cur
|       |  |       |    ........    |       |
|       |  |       |                |       |
|       |  |       |                |       |
|_______|  |_______|                |_______|
 (page1)    (page2)                  (pagen) 


--------------------------------------------------------------------------------
[块头的数据结构]：
struct gc_block_header
{
    unsigned int h_flags; 
    unsigned int h_free;   #0<=h_free<page_size
};

[成员说明]
1)成员h_flags用于处于该块中的对象的一些信息，这些信息有：
     （a）是否为静态数据区，
     （b）是年轻分代还是老化分代
2)成员h_free用于表明该块中自由，也就是未分配的区域的位置。

[快照]
下图为页头在某个时刻的状态
             ______________________
            |                      |
            |   gc_block_header    |
            |______________________|
            |     object_1         |
            |______________________|
            |     object_2         |
            |______________________|
            |     ........         |
            |______________________|
            |     object_n         |
            |______________________|
            |                      | <---h_free
            |    not allocate      |
            |                      |
            |______________________|


--------------------------------------------------------------------------------
[获得对象所处的块头]
    Object.GetBlockHeader()
        return Object&GC_HEAP_BLOCK_MASK  
    end
    
    其中GC_HEAP_BLOCK_MASK的值为(~((1<<PAGE_SHIFT)-1));
    如果页的大小为4k，那么 PAGE_SHIFT=12

[分配一个对象单元]
    因为codger中的对象的大小都比较小，所以下面函数不会出错
    
    GcHeap.New(TypeName)
        size=sizeof(TypeName);
        header=GcHeap.b_cur;
        if size+header>GC_HEAP_BLOCK_MAX   #如果当前块没有空间
            GcHeap.Enlarge()               #扩展堆
            header=GcHeap.b_cur;           #获得新的块
        end
        
        addr=header.h_free+header;         #分配对象的地址
        header.h_free+=size;               #更新块的自由空间
        return addr
    end


--------------------------------------------------------------------------------
[整个gc模块的数据结构]
struct gc_module
{
    struct gc_heap* g_young;    #年轻代对象
    struct gc_heap* g_old;      #老化代对象
    struct gc_heap* g_static;   #静态数据区
};






